/// Example HTTP server to demonstrate loading of assets from webdev.
///
/// This server demonstrates the use of the webdev_proxy package to either:
///
/// - Serve assets from a directory generated by running "webdev build".
///   This is for when it is deployed in production.
/// - Serve assets by proxying the HTTP requests to a separately running
///   "webdev serve" process. This is used when debugging the client-side Dart
///   scripts.
///
/// See README for instructions.

import 'dart:io';

import 'package:logging/logging.dart';

import 'package:webdev_proxy/webdev_proxy.dart' as webdev_proxy;

//================================================================

final Logger _log = Logger('example');

// Logging level displayed.
//
// Normally, the default level should be Level.INFO.
// Use Level.FINE to see missing files or non-2xx responses from webdev serve.
// Use Level.FINER to also log every HTTP request.
// Use Level.FINEST to also log every HTTP header from/to the webdev serve.

const Level defaultLoggingLevel = Level.FINE;

//================================================================

Future<void> main(List<String> arguments) async {
  // Determine default directory containing the files from "webdev build".
  // Normally it is called "build" in the project's top level directory, and
  // this script file is in a subdirectory of it.

  final packageDir = FileSystemEntity.parentOf(
      FileSystemEntity.parentOf(Platform.script.path));
  final defaultBuildDir = '$packageDir${Platform.pathSeparator}build';

  // Process command line arguments

  String buildDir;
  String webdevServeUrl;

  var usageError = false;
  if (arguments.isEmpty) {
    buildDir = defaultBuildDir;
  } else if (arguments.length == 2) {
    if (arguments[0] == '-d' || arguments[0] == '--debug') {
      webdevServeUrl = arguments[1];
    } else if (arguments[0] == '-b' || arguments[0] == '--build') {
      buildDir = arguments[1];
    } else {
      usageError = true;
    }
  } else {
    usageError = true;
  }
  if (usageError) {
    stdout.write('''Usage: example [options]
  -b | --build dir  - directory from "webdev build" (default: $defaultBuildDir)
  -d | --debug url  - URL for "webdev serve" (e.g. http://localhost:8080)
Note: at most, only one of --build or --debug can be used
''');
    exitCode = 0;
    return;
  }

  // Set up logging

  Logger.root.level = defaultLoggingLevel; // TODO: configure via command line
  Logger.root.onRecord.listen((logRec) {
    print('${logRec.time} ${logRec.level.name.padRight(8)}: ${logRec.message}');
  });

  // Run the server

  try {
    await runServer(
        debugMode: webdevServeUrl != null,
        buildDir: buildDir,
        webdevServeUrl: webdevServeUrl);
    // ignore: avoid_catching_errors
  } on ArgumentError catch (e) {
    stderr.write('Error: $e\n');
    exitCode = 1;
  }
}

//----------------------------------------------------------------
/// Create the HTTP server and process the HTTP requests.

Future<void> runServer({
  String host = 'localhost',
  int port = 8000,
  bool debugMode = false,
  String buildDir,
  String webdevServeUrl,
}) async {
  // Check parameters are suitable

  Uri webdevServe;

  if (!debugMode) {
    // Production mode: assetDir needed
    if (buildDir == null) {
      throw ArgumentError.notNull('buildDir');
    }
    if (!buildDir.startsWith(Platform.pathSeparator)) {
      throw ArgumentError.value(buildDir, 'buildDir', 'not an absolute path');
    }
    if (!Directory(buildDir).existsSync()) {
      throw ArgumentError.value(buildDir, 'buildDir', 'does not exist');
    }
    _log.config('build directory: $buildDir');
    // Note: [webdevServer] remains null, since it won't be needed
  } else {
    // Debug mode: webdev serve needed
    if (webdevServeUrl == null) {
      throw ArgumentError.notNull('webdevServeUrl');
    }
    if (!webdevServeUrl.startsWith('http://')) {
      throw ArgumentError.value(webdevServeUrl, 'webdevServeUrl', 'not http');
    }
    _log.config('webdev server: $webdevServeUrl');
    webdevServe = Uri.parse(webdevServeUrl); // parse String to Uri
  }

  // Start the server and handle requests

  final server = await HttpServer.bind(host, port);

  _log.info('listening on <http://$host:$port/>');

  await for (final req in server) {
    _log.finer('${req.method} ${req.uri}');

    switch (req.method) {
      case 'GET':
        await processGet(req,
            debugMode: debugMode, buildDir: buildDir, webdevServe: webdevServe);
        break;
      // case 'POST':
      //   break;
      default:
        await errorResponse(req, HttpStatus.methodNotAllowed,
            'method not supported: ${req.method}');
        break;
    }
  }
}

//----------------------------------------------------------------
/// Process all HTTP GET requests.
///
/// If [debugMode] is true, [webdevServe] must have a value (i.e. must not be
/// null). Otherwise, [buildDir] must have a value.

Future<void> processGet(HttpRequest req,
    {bool debugMode, String buildDir, Uri webdevServe}) async {
  final responseGenerated = await generateResponse(req);

  if (!responseGenerated) {
    // All other requests should be for the client-side scripts and static files

    //********
    // This is the main part of this example.
    //
    // When HTTP GET requests are not processed by this server, they are handled
    // by the webdev_proxy package. Either by serving up files from a directory
    // (when running in production mode) or proxying the requests through to
    // a separate HTTP server (when running in debug mode).
    //
    // This allows client-side Dart scripts to be supported when running in
    // production mode or debug mode. Other files from the "web" directory
    // (such as CSS stylesheets and images) are also handled by this mechanism.
    //********

    try {
      if (!debugMode) {
        // Production mode: serve files from the "webdev build" directory
        await webdev_proxy.respondFromBuild(req, buildDir);
      } else {
        // Debug mode: proxy requests through to the running "webdev serve"
        await webdev_proxy.respondFromServe(req, webdevServe);
      }
    } on webdev_proxy.BadRequest {
      await errorResponse(req, HttpStatus.badRequest, 'bad request');
    } on webdev_proxy.FileNotFound {
      await errorResponse(req, HttpStatus.notFound, 'file not found');
    } on webdev_proxy.ServerUnavailable {
      await errorResponse(req, HttpStatus.internalServerError,
          'could not contact webdev serve: $webdevServe');
    }
  }
}

//----------------------------------------------------------------
// Dynamically generated HTTP responses

// These values must match those expected by the client-side script.

const String hiddenClassName = 'hidden-by-script';
const String successId = 'success';

//----------------
// Generated pages (map of the URL path to the HTML content).

const Map<String, String> pageContent = {
  '/': '''
<html>
<head>
  <title>DHTML Server: Home</title>
  <link rel="stylesheet" href='/style/site.css'/>
  <style type="text/css">p.error { color: darkred; }</style>
  <script src="/scripts/example_script.dart.js" type="text/javascript" defer>
  </script>
</head>
<body>
<h1>Test</h1>
<nav>Home</nav>

<p>This is the top page. Try loading the <a href='foo/absolute'>absolute</a> and
<a href='foo/relative'>relative</a> test pages.</p>

<img class="logo" src="/images/dart-logo.png" alt="Image did not load"/>

<div class="hidden-by-css">
  <!-- if the CSS loads, this will not be shown -->
  <p class="error">Error: CSS file did not load.</p>
</div>

<div class="$hiddenClassName">
  <!-- If the JavaScript loads and runs properly, this will not be shown -->
  <p class="error">Error: client-side script did not run.</p>
</div>

<div id="$successId"></div>

<p id="hit-count">{{HITCOUNT}}</p>

<p class="note">Note: the browser cache might prevent new changes from
appearing. Force reload if expected changes are not appearing.</p>
</body>
</html>
  ''',
  '/foo/absolute': '''
<html>
<head>
  <title>DHTML Server: absolute</title>
  <link rel="stylesheet" href='/style/site.css'/>
  <style type="text/css">p.error { color: darkred; }</style>
  <script src="/scripts/example_script.dart.js" type="text/javascript" defer>
  </script>
</head>
<body>
<h1>Absolute test</h1>
<nav><a href="/">Home</a></nav>

<p>This page uses absolute links to the stylesheet, image and scripts.</p>

<img class="logo" src="/images/dart-logo.png" alt="Image did not load"/>

<div class="hidden-by-css">
  <!-- if the CSS loads, this will not be shown -->
  <p class="error">Error: CSS file did not load.</p>
</div>

<div class="$hiddenClassName">
  <!-- If the JavaScript loads and runs properly, this will not be shown -->
  <p class="error">Error: client-side script did not run.</p>
</div>

<div id="$successId"></div>

<p id="hit-count">{{HITCOUNT}}</p>

<p class="note">Note: the browser cache might prevent new changes from
appearing. Force reload if expected changes are not appearing.</p>

</body>
</html>
''',
  '/foo/relative': '''
<html>
<head>
  <title>DHTML Server: relative</title>
  <link rel="stylesheet" href='../../style/site.css'/>
  <style type="text/css">p.error { color: darkred; }</style>
  <script src="../../scripts/example_script.dart.js" type="text/javascript"
   defer></script>
</head>
<body>
<h1>Relative test</h1>
<nav><a href="../..">Home</a></nav>

<p>This page uses relative links to the stylesheet, image and scripts.</p>

<img class="logo" src="/images/dart-logo.png" alt="Image did not load"/>

<div class="hidden-by-css">
  <!-- if the CSS loads, this will not be shown -->
  <p class="error">Error: CSS file did not load.</p>
</div>

<div class="$hiddenClassName">
  <!-- If the JavaScript loads and runs properly, this will not be shown -->
  <p class="error">Error: client-side script did not run.</p>
</div>

<div id="$successId"></div>

<p id="hit-count">{{HITCOUNT}}</p>

<p class="note">Note: the browser cache might prevent new changes from
appearing. Force reload if expected changes are not appearing.</p>

</body>
</html>
''',
};

/// Hit counter.

int hitCount = 0;

//----------------
/// Generates a HTTP responses for GET requests for generated pages.
///
/// Returns a Future to true, if the HTTP response was generated.
/// Returns a Future to false, if the request is not for a generated page.

Future<bool> generateResponse(HttpRequest req) async {
  var content = pageContent[req.uri.toString()];

  if (content != null) {
    // Request is dynamically generated by this server: produce HTTP response

    final resp = req.response;

    resp.headers.contentType = ContentType.html;
    resp.statusCode = HttpStatus.ok;

    // Update hit counter. This is just to make the content dynamic, otherwise
    // the same result could have been achieved using static HTML files in the
    // "web" directory.

    hitCount++;
    content = content.replaceAll('{{HITCOUNT}}', hitCount.toString());

    resp.write(content);

    await resp.close();
    return true;
  } else {
    // Request is not dynamically generated by this server
    return false;
  }
}

//----------------------------------------------------------------
/// Generates a HTTP response for an error.
///
/// The HTTP response with have [httpStatus] as its response status and will
/// contain the [message].

Future<void> errorResponse(
    HttpRequest req, int httpStatus, String message) async {
  //_log.warning('${req.method} ${req.uri}: status $httpStatus: $message');

  final resp = req.response
    ..statusCode = httpStatus
    ..headers.contentType = ContentType.text
    ..write('Error: $message: ${req.uri}\n');

  await resp.close();
}
